# ANYTLS: A Multiplexed Application-Layer Connection Protocol over TLS

# Overview

ANYTLS is a multiplexed application layer connection protocol. 

This document defines version 1 of ANYTLS.

## Terms and Definitions

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**NOT RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in BCP 14 [[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)] [[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they appear in all capitals, as shown here.

Commonly used terms in this document are described below.

- **ANYTLS:** The protocol described by this document.
- **Endpoint:** An entity that can participate in a ANYTLS connection by generating, receiving, and processing ANYTLS frames. There are only two types of endpoints in ANYTLS: client and server.
- **Client:** The endpoint that initiates a ANYTLS connection.
- **Server:** The endpoint that accepts a ANYTLS connection.
- **Frame:** A unit of structured protocol information. There are multiple frame types, each of which carries different information. Frames are contained in TLS Record Section
- **ANYTLS Connection:** Logically, ANYTLS Connection is an upgrade from TLS Connection, but in reality, ANYTLS Connection is still TLS Connection.
- **Stream:** A bidirectional channel of ordered bytes within a ANYTLS connection. A ANYTLS connection can carry multiple simultaneous streams.
- **Stream ID**: It is used to identify different streams in an ANYTLS connection.
- **Application:** An entity that uses ANYTLS to send and receive data.

This document uses the terms "ANYTLS Frame", "TLS Record", and "TCP packets" to refer to the units of the respective protocols. 

That is, one or more ANYTlS frame can be encapsulated in a TLS record, which is in turn encapsulated in an TCP packet.

## Notational Conventions

Frame diagrams in this document use a custom format. The purpose of this format is to summarize, not define, protocol elements. Prose defines the complete semantics and details of structures.

Complex fields are named and then followed by a list of fields surrounded by a pair of matching braces. Each field in this list is separated by commas.

Individual fields include length information, plus indications about fixed value, optionality, or repetitions. Individual fields use the following notational conventions, with all lengths in bits:

**x (A):** Indicates that x is A bits long

**x (i):** Indicates that x holds an integer value using the variable-length encoding described in [Section 16](https://datatracker.ietf.org/doc/html/rfc9000#integer-encoding)

**x (A..B):** Indicates that x can be any length from A to B; A can be omitted to indicate a minimum of zero bits, and B can be omitted to indicate no set upper limit; values in this format always end on a byte boundary

**x (L) = C:** Indicates that x has a fixed value of C; the length of x is described by L, which can use any of the length forms above

**x (L) = C..D:** Indicates that x has a value in the range from C to D, inclusive, with the length described by L, as above

**[x (L)]:** Indicates that x is optional and has a length of L

**x (L) ...:** Indicates that x is repeated zero or more times and that each instance has a length of L

This document uses network byte order (that is, big endian) values. Fields are placed starting from the high-order bits of each byte.

By convention, individual fields reference a complex field by using the name of the complex field.

```
Example Structure {
  One-bit Field (1),
  7-bit Field with Fixed Value (7) = 61,
  Field with Variable-Length Integer (i),
  Arbitrary-Length Field (..),
  Variable-Length Field (8..24),
  Field With Minimum Length (16..),
  Field With Maximum Length (..128),
  [Optional Field (64)],
  Repeated Field (8) ...,
}
```

# Connections

An ANYTLS Connection **MUST** be established over a TLS connection which in turn **MUST** use a reliable, connection-oriented transport protocol, specifically **TCP**. 

Implementations **MUST NOT** attempt to run ANYTLS over datagram protocols such as **UDP**.

The TLS layer **MUST** use TLS version 1.3 or higher.

## Authentication

The client and the server each maintain an **independent** ANYTLS Connection state machine. 

These state machines are **not synchronized** and **MUST** be evaluated independently.

After the TLS handshake completes, the client **MUST** immediately send an **AUTH frame**.

Immediately after sending the **AUTH frame**, the client **MUST** send a **NEGO frame**.

From the client’s perspective, once the **AUTH frame** has been sent, the underlying TLS connection is considered **upgraded to an ANYTLS Connection**.

Upon receiving the **AUTH frame**, the server performs authentication processing.

The **AUTH frame** **MUST** be in the **first application-level data** received by the server from the client **after completion of the TLS handshake**.

If the server receives any other data from the client before the AUTH frame, the authentication **MUST** be considered failed.

If authentication succeeds, the server transitions the underlying TLS connection to an ANYTLS Connection.

If authentication fails, the server **SHOULD** take one of the following actions:

- Immediately terminate the TLS connection; or
- Redirect subsequent data to a preconfigured endpoint.

After an ANYTLS Connection has been established, all data sent by the client to the server **MUST** conform to the formats defined by the ANYTLS specification.

If the received data does not conform to the ANYTLS specification, the server **SHOULD** take one of the following actions:

- Send an **ALERT frame** to the client and immediately terminate the TLS connection; or
- Downgrade the connection to a plain TLS connection; or
- Redirect the data stream to a preconfigured service (for example, an HTTP server).

## Version Negotiation

The client **MUST** send a NEGO frame immediately after sending the AUTH frame.

The client NEGO frame **MUST** include the following information:

- The protocol version supported by the client
- The client’s ANYTLS implementation identifier
- The padding scheme used by the client

From the client’s perspective, once the AUTH frame has been sent, version negotiation is considered successful.

Upon receiving the NEGO frame, the server **MUST** immediately respond to the client with a NEGO frame.

The server NEGO frame **MUST** include the protocol version selected by the server.

If the protocol version requested by the client is not supported, the server **MUST** immediately send a **CLOSE frame** and then terminate the ANYTLS connection.

## Padding Scheme Update

If version negotiation succeeds, but the padding scheme indicated by the client differs from the padding scheme used by the server, the server **MUST** immediately send the padding scheme it uses to the client.

For the first ANYTLS connection established between a given client and server, the server **MAY** accept the padding scheme proposed by the client.

For any subsequent ANYTLS connections established between the same client and server, the client **MUST** strictly use the padding scheme selected by the server.

## Timeout

The ANYTLS connection state maintained by the client and the server is not synchronized.

To prevent resource exhaustion and other latent issues, a timeout mechanism MUST be implemented for ANYTLS connections.

If no ANYTLS frame is transmitted within a specified period of time, the ANYTLS connection MUST be terminated.

The client and the server MUST each maintain an independent timer for this purpose.

## Connection States Machine

### Server Connection State Machine

### Client Connection State Machine

# Streams

An ANYTLS Connection supports multiple logical streams.

## Control Stream

An ANYTLS Connection contains a permanent, implicit **Control Stream**, identified by `StreamId = 0`.

The Control Stream is reserved for protocol negotiation, connection maintenance, and other connection-level control functions.

## Explicit Data Streams

All streams other than the Control Stream are **Explicit Data Streams**.

An Explicit Data Stream **MUST** be explicitly opened by transmitting a STREAM frame with the **OPEN** bit set.

## Explicit Data Stream Identifiers

Each ANYTLS Connection defines an independent Stream ID space.

Explicit Data Stream IDs:

- **MUST** be greater than zero;
- **MUST** be unique within the connection;
- **MUST** be allocated as monotonically increasing integers.

The valid Stream ID space ranges from **1** to **2⁶² − 1**, inclusive.

## Stream Timeout

The stream state maintained by the client and the server is not synchronized.

To prevent resource exhaustion and other latent issues, a timeout mechanism **MUST** be implemented for each stream.

If no STREAM frame associated with a given Stream ID is transmitted within a specified period of time, that stream **MUST** be automatically terminated.

The client and the server **MUST** each maintain an independent timer for every stream.

# Frames

## Frames Types and Formats

### AUTH Frame

```
Auth Frame{
	type(i)=0x00,
	stream_id(i)=0x00,
	password_hash(32*8),
	padding_length(i), 
	padding(..)
}
```

### ALERT Frame (cmdAlert)

```
Alert {
	type(i)=0x01,
  stream id(i)=0x00,
  length(i),
  error(..)
}
```

### Close Frame 

```
Alert {
	type(i)=0x02, 
  stream_id(i)=0x00,
  error_code(i), 
}
```

### Nego Frame(cmdSettings+cmdServerSettings)

```
Nego Frame {
	type(i)=0x03, // Client Side
	stream_id(i)=0x00,
	length(i),
	data(..)
}

Nego Frame {
	type(i)=0x04, // Server Side
	stream_id(i)=0x06, 
	length(i),
	data(..)
}
```

### PADDING Frame (cmdWaste)

```
PADDING Frame{
	type(i)=0x05,
	stream_id(i)=0x00,
	length(i),
	data(..),
}
```

### PADDING_UPDATE_SCHEME Frame(cmdUpdatePaddingScheme)

```
PADDING_UPDATE_SCHEME Frame{
	type(i)=0x06,
	stream_id(i)=0x00,
	length(i),
	data(..),
}
```

### PINGPONG Frame (cmdHeartRequest+cmdHeartResponse)

```
PINGPONG {
	type(i)=0x07,
  stream_id(i)=0x00
}
```

### STREAM Frame Class

- 0x08-0x0F
- **High-order: bits** `0b1000` indicates the **STREAM frame class**.
- **Low-order 3 bits:** The lower 3 bits carry the **semantic flags**.

```
  3    2    1    0
Class OPEN DATA RST
```



```
// type=0x09 (cmdFIN)
STREAM Frame{
	type(i)=0x09, // 1 001
	stream_id(i)
}

// type=0x10(cmdPSH)
STREAM Frame{
	type(i)=0x10, // 1 010
	stream_id(i),
	length(i),
	data(i),
}

// type=0x0C (cmdSYN)
STREAM Frame{
	type(i)=0x0C, // 1 100
	stream_id(i),
}
```

### STREAM_ACK (cmdSYNACK)

```
STREAM Frame{
	type(i)=0x10,
	stream_id(i)
}
```

# AnyTLS Legacy Traffic Shaping Scheme v0

This scheme specifies the legacy traffic shaping behavior that is behaviorally compatible with the original AnyTLS implementation.

## Core Concepts

**Deliver**

- **Definition**: A single logical operation where the application layer submits data (either a standalone Frame or a Coalesced Buffer) to the Traffic Shaper.
- **Significance**: It serves as the discrete unit for the Shaping Threshold (`Stop`) counter.

**ShapingQuota (Shaping Threshold)**

- **Definition**: The maximum number of **Deliver** operations to be processed by the Traffic Shaper.
- **Behavior**: The shaper maintains a counter incremented at the start of each Deliver. Once the counter reaches the `Stop` value, shaping logic (padding and segmentation) is disabled, and subsequent data is passed directly to the underlying connection.

**Write**

- **Definition**: **Definition**: The **actual operation** of submitting a byte data to the underlying TLS connection (e.g., calling `net.Conn.Write` in golang).
- **Relationship**: A single **Deliver** may trigger one, or multiple **Write** operations depending on the length-shaping strategy.

## Implementation

### Phase 1: Initial Frame Coalescing (Index 0 Deliver)

To minimize the exposure of protocol-specific metadata, the implementation **SHOULD** aggregate the initial set of control frames into a single buffer before any actual data is transmitted. This is an **Optimistic Transmission**; the client does not wait for server acknowledgement.

Frames to coalesce:

1. **AUTH Frame** (`cmdSettings`): Contains version and padding configuration hash.
2. **NEGO Frame**: Contains peer-specific configuration.
3. **STREAM OPEN Frame** (`cmdSYN`): The request to initiate a stream.

This aggregated block is treated as the **first Deliver (Index 0)**.

**Technical Note on TLS Encapsulation:**
While the underlying TLS stack is a "black box" that may fragment data into multiple TLS Records, submitting these frames via a single **Write** is a best-effort approach to encourage the TLS layer to group the protocol overhead into as few records as possible.

### Phase 2: Discrete Delivery (Post-Initialization)

Once the initial coalesced buffer is flushed:

- **Frame-to-Deliver Mapping**: Each subsequent application Frame (e.g., `cmdPSH`) SHOULD be treated as an individual **Deliver** operation.
- **Counter Increment**: Each Deliver increments the session's `Stop` counter.
- **Shaping Enforcement**: While the counter is below `Stop`, the shaper applies the `PaddingScheme`:
- **Segmentation**: If the Deliver data exceeds the target length , it is split into multiple **Write** operations.
- **Padding**: If the Deliver data is shorter than , a `cmdWaste` frame is appended to the data before an actual **Write** is executed.

### Phase 3: Residual Handling

If the shaping strategy for a specific Deliver is exhausted (e.g., all sizes in `pktSizes` have been used) but user data remains in the current Deliver buffer, the remaining data MUST be transmitted immediately via an unshaped **Write**.

| **状态 (State)** | **触发条件 (Trigger)** | **动作 (Action)** | **下一个状态** |
| --- | --- | --- | --- |
| **Initializing** | Session Start | Buffer AUTH + NEGO | Initializing |
| **Flushing** | First App Data | Concat Buffer; Execute Deliver 0; Write(s) | **Shaping** |
| **Shaping** | Deliver < Quota | Apply Padding/Segmentation; Write(s) | Shaping |
| **Passthrough** | Deliver >= Quota | `s.conn.Write(b)` (Raw) | Passthrough |

# Appendix A. AnyTLS Data Block K-V Serialization Format v0

## Character Set

- All data **MUST** be encoded in UTF-8.
- Only characters in the ASCII range `0x21`–`0x7E` are permitted, except `LF (0x0A)` which is used as line terminator.
- Multi-byte UTF-8 characters are **NOT ALLOWED**.
- UTF-8 BOM (`0xEF 0xBB 0xBF`) is **NOT ALLOWED**.

This makes the format strictly ASCII-safe while formally defined as UTF-8.

## Line Structure

- A KV data block consists of one or more **KV lines**.
- Each line is terminated by a single Line Feed:

```
LF =0x0A
```

- **CR (0x0D)** is **NOT ALLOWED**.

## KV Line Grammar

Each line has the form:

```
key"=" value-list LF
```

Where:

- The **first** equals sign (`=`, `0x3D`) is the key–value delimiter.
- Any additional `=` characters belong to the value field.

## Key

- A key **MUST NOT** be empty.
- A key **MUST NOT** contain:
    - `=` (0x3D)
    - `,` (0x2C)
    - space (0x20)
- Keys are case-sensitive.
- Each key in a data block **MUST** be unique.

## Value List

- The value field is a comma-separated list:

```
value-list = value *("," value )
```

- A value **MUST NOT** be empty.
- A value **MUST NOT** contain:
    - `,` (0x2C)
    - space (0x20)
    - `LF` (0x0A)

## Validation Rules

An implementation **MUST reject** a data block if any of the following is true:

1. A line does not contain an equals sign (`=`).
2. A key appears more than once.
3. Any key or value is empty.
4. Any forbidden character appears in key or value.
5. Any character outside permitted ASCII range is present.
6. The space character (`0x20`) is **NOT ALLOWED** anywhere in the data block.

## Example

```
proto=anytls
version=1,2,3
framing=stream,obfs
cipher=chacha20-poly1305
```

# Appendix B. AnyTLS Data Block — TEXT Serialization v0

## Encoding

- Data **MUST** be encoded in UTF-8.
- Multi-byte UTF-8 characters are **NOT ALLOWED**.
- UTF-8 BOM (`0xEF 0xBB 0xBF`) is **NOT ALLOWED**.

## Character Set

- Only characters in the ASCII range `0x20–0x7E` are permitted.
- Line Feed (`LF`, `0x0A`) is permitted as a line separator.
- All other control characters (`0x00–0x1F`, `0x7F`) are **NOT ALLOWED**.

This makes the payload human-readable and terminal-safe.

## Structure

- The entire data block is treated as a single **opaque text string**.
- No key–value semantics, no field separators, no escaping, no schema.
- Line breaks, if present, have **no semantic meaning** beyond text layout.

## Validation Rules

An implementation **MUST reject** the data block if:

1. It contains any byte sequence that is not valid UTF-8.
2. It contains BOM.
3. It contains any disallowed control character.

## Example

```
Hello AnyTLS
thisis a raw text block
no structure here
```

# Appendix C. Variable-Length Integer Encoding

ANYTLS frames commonly use a variable-length encoding for non-negative integer values. This encoding ensures that smaller integer values need fewer bytes to encode.

The variable-length integer encoding reserves the two most significant bits of the first byte to encode the base-2 logarithm of the integer encoding length in bytes. The integer value is encoded on the remaining bits, in network byte order.

This means that integers are encoded on 1, 2, 4, or 8 bytes and can encode 6-, 14-, 30-, or 62-bit values, respectively.

| 2MSB | Length | Usable Bits | Range |
| --- | --- | --- | --- |
| 00 | 1 | 6 | 0-63 |
| 01 | 2 | 14 | 0-16383 |
| 10 | 4 | 30 | 0-1073741823 |
| 11 | 8 | 62 | 0-4611686018427387903 |
