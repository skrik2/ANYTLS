# ANYTLS: A Multiplexed Application-Layer Connection Protocol over TLS

# Overview

ANYTLS is a multiplexed application layer connection protocol. 

This document defines version 1 of ANYTLS.

## Terms and Definitions

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**NOT RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in BCP 14 [[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)] [[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they appear in all capitals, as shown here.

Commonly used terms in this document are described below.

- **ANYTLS:** The protocol described by this document.
- **Endpoint:** An entity that can participate in a ANYTLS connection by generating, receiving, and processing ANYTLS frames. There are only two types of endpoints in ANYTLS: client and server.
- **Client:** The endpoint that initiates a ANYTLS connection.
- **Server:** The endpoint that accepts a ANYTLS connection.
- **Frame:** A unit of structured protocol information. There are multiple frame types, each of which carries different information. Frames are contained in TLS Record Section
- **ANYTLS Connection:** Logically, ANYTLS Connection is an upgrade from TLS Connection, but in reality, ANYTLS Connection is still TLS Connection.
- **Stream:** A bidirectional channel of ordered bytes within a ANYTLS connection. A ANYTLS connection can carry multiple simultaneous streams.
- **Stream ID**: It is used to identify different streams in an ANYTLS connection.
- **Application:** An entity that uses ANYTLS to send and receive data.

This document uses the terms "ANYTLS Frame", "TLS Record", and "TCP packets" to refer to the units of the respective protocols. 

That is, one or more ANYTlS frame can be encapsulated in a TLS record, which is in turn encapsulated in an TCP packet.

## Notational Conventions

Frame diagrams in this document use a custom format. The purpose of this format is to summarize, not define, protocol elements. Prose defines the complete semantics and details of structures.

Complex fields are named and then followed by a list of fields surrounded by a pair of matching braces. Each field in this list is separated by commas.

Individual fields include length information, plus indications about fixed value, optionality, or repetitions. Individual fields use the following notational conventions, with all lengths in bits:

**x (A):** Indicates that x is A bits long

**x (i):** Indicates that x holds an integer value using the variable-length encoding described in [Section 16](https://datatracker.ietf.org/doc/html/rfc9000#integer-encoding)

**x (A..B):** Indicates that x can be any length from A to B; A can be omitted to indicate a minimum of zero bits, and B can be omitted to indicate no set upper limit; values in this format always end on a byte boundary

**x (L) = C:** Indicates that x has a fixed value of C; the length of x is described by L, which can use any of the length forms above

**x (L) = C..D:** Indicates that x has a value in the range from C to D, inclusive, with the length described by L, as above

**[x (L)]:** Indicates that x is optional and has a length of L

**x (L) ...:** Indicates that x is repeated zero or more times and that each instance has a length of L

This document uses network byte order (that is, big endian) values. Fields are placed starting from the high-order bits of each byte.

By convention, individual fields reference a complex field by using the name of the complex field.

```
Example Structure {
  One-bit Field (1),
  7-bit Field with Fixed Value (7) = 61,
  Field with Variable-Length Integer (i),
  Arbitrary-Length Field (..),
  Variable-Length Field (8..24),
  Field With Minimum Length (16..),
  Field With Maximum Length (..128),
  [Optional Field (64)],
  Repeated Field (8) ...,
}
```

# Connections

An ANYTLS Connection **MUST** be established over a TLS connection which in turn **MUST** use a reliable, connection-oriented transport protocol, specifically **TCP**. 

Implementations **MUST NOT** attempt to run ANYTLS over datagram protocols such as **UDP**.

The TLS layer **MUST** use TLS version 1.3 or higher.

## Authentication

The client and the server each maintain an **independent** ANYTLS Connection state machine. 

These state machines are **not synchronized** and **MUST** be evaluated independently.

After the TLS handshake completes, the client **MUST** immediately send an **AUTH frame**.

Immediately after sending the **AUTH frame**, the client **MUST** send a **NEGO frame**.

From the client’s perspective, once the **AUTH frame** has been sent, the underlying TLS connection is considered **upgraded to an ANYTLS Connection**.

Upon receiving the **AUTH frame**, the server performs authentication processing.

The **AUTH frame** **MUST** be in the **first application-level data** received by the server from the client **after completion of the TLS handshake**.

If the server receives any other data from the client before the AUTH frame, the authentication **MUST** be considered failed.

If authentication succeeds, the server transitions the underlying TLS connection to an ANYTLS Connection.

If authentication fails, the server **SHOULD** take one of the following actions:

- Immediately terminate the TLS connection; or
- Redirect subsequent data to a preconfigured endpoint.

After an ANYTLS Connection has been established, all data sent by the client to the server **MUST** conform to the formats defined by the ANYTLS specification.

If the received data does not conform to the ANYTLS specification, the server **SHOULD** take one of the following actions:

- Send an **ALERT frame** to the client and immediately terminate the TLS connection; or
- Downgrade the connection to a plain TLS connection; or
- Redirect the data stream to a preconfigured service (for example, an HTTP server).

## Version Negotiation

The client **MUST** send a NEGO frame immediately after sending the AUTH frame.

The client NEGO frame **MUST** include the following information:

- The protocol version supported by the client
- The client’s ANYTLS implementation identifier
- The padding scheme used by the client

From the client’s perspective, once the AUTH frame has been sent, version negotiation is considered successful.

Upon receiving the NEGO frame, the server **MUST** immediately respond to the client with a NEGO frame.

The server NEGO frame **MUST** include the protocol version selected by the server.

If the protocol version requested by the client is not supported, the server **MUST** immediately send a **CLOSE frame** and then terminate the ANYTLS connection.

## Padding Scheme Update

If version negotiation succeeds, but the padding scheme indicated by the client differs from the padding scheme used by the server, the server **MUST** immediately send the padding scheme it uses to the client.

For the first ANYTLS connection established between a given client and server, the server **MAY** accept the padding scheme proposed by the client.

For any subsequent ANYTLS connections established between the same client and server, the client **MUST** strictly use the padding scheme selected by the server.

## Timeout

The ANYTLS connection state maintained by the client and the server is not synchronized.

To prevent resource exhaustion and other latent issues, a timeout mechanism MUST be implemented for ANYTLS connections.

If no ANYTLS frame is transmitted within a specified period of time, the ANYTLS connection MUST be terminated.

The client and the server MUST each maintain an independent timer for this purpose.

## Connection States Machine

### Server Connection State Machine

### Client Connection State Machine

# Streams

An ANYTLS Connection supports multiple logical streams.

## Control Stream

An ANYTLS Connection contains a permanent, implicit **Control Stream**, identified by `StreamId = 0`.

The Control Stream is reserved for protocol negotiation, connection maintenance, and other connection-level control functions.

## Explicit Data Streams

All streams other than the Control Stream are **Explicit Data Streams**.

An Explicit Data Stream **MUST** be explicitly opened by transmitting a STREAM frame with the **OPEN** bit set.

## Explicit Data Stream Identifiers

Each ANYTLS Connection defines an independent Stream ID space.

Explicit Data Stream IDs:

- **MUST** be greater than zero;
- **MUST** be unique within the connection;
- **MUST** be allocated as monotonically increasing integers.

The valid Stream ID space ranges from **1** to **2⁶² − 1**, inclusive.

# Appendix A. AnyTLS Data Block K-V Serialization Format v0

## Character Set

- All data **MUST** be encoded in UTF-8.
- Only characters in the ASCII range `0x21`–`0x7E` are permitted, except `LF (0x0A)` which is used as line terminator.
- Multi-byte UTF-8 characters are **NOT ALLOWED**.
- UTF-8 BOM (`0xEF 0xBB 0xBF`) is **NOT ALLOWED**.

This makes the format strictly ASCII-safe while formally defined as UTF-8.

## Line Structure

- A KV data block consists of one or more **KV lines**.
- Each line is terminated by a single Line Feed:

```
LF =0x0A
```

- **CR (0x0D)** is **NOT ALLOWED**.

## KV Line Grammar

Each line has the form:

```
key"=" value-list LF
```

Where:

- The **first** equals sign (`=`, `0x3D`) is the key–value delimiter.
- Any additional `=` characters belong to the value field.

## Key

- A key **MUST NOT** be empty.
- A key **MUST NOT** contain:
    - `=` (0x3D)
    - `,` (0x2C)
    - space (0x20)
- Keys are case-sensitive.
- Each key in a data block **MUST** be unique.

## Value List

- The value field is a comma-separated list:

```
value-list = value *("," value )
```

- A value **MUST NOT** be empty.
- A value **MUST NOT** contain:
    - `,` (0x2C)
    - space (0x20)
    - `LF` (0x0A)

## Validation Rules

An implementation **MUST reject** a data block if any of the following is true:

1. A line does not contain an equals sign (`=`).
2. A key appears more than once.
3. Any key or value is empty.
4. Any forbidden character appears in key or value.
5. Any character outside permitted ASCII range is present.
6. The space character (`0x20`) is **NOT ALLOWED** anywhere in the data block.

## Example

```
proto=anytls
version=1,2,3
framing=stream,obfs
cipher=chacha20-poly1305
```

# Appendix B. AnyTLS Data Block — TEXT Serialization v0

## Encoding

- Data **MUST** be encoded in UTF-8.
- Multi-byte UTF-8 characters are **NOT ALLOWED**.
- UTF-8 BOM (`0xEF 0xBB 0xBF`) is **NOT ALLOWED**.

## Character Set

- Only characters in the ASCII range `0x20–0x7E` are permitted.
- Line Feed (`LF`, `0x0A`) is permitted as a line separator.
- All other control characters (`0x00–0x1F`, `0x7F`) are **NOT ALLOWED**.

This makes the payload human-readable and terminal-safe.

## Structure

- The entire data block is treated as a single **opaque text string**.
- No key–value semantics, no field separators, no escaping, no schema.
- Line breaks, if present, have **no semantic meaning** beyond text layout.

## Validation Rules

An implementation **MUST reject** the data block if:

1. It contains any byte sequence that is not valid UTF-8.
2. It contains BOM.
3. It contains any disallowed control character.

## Example

```
Hello AnyTLS
thisis a raw text block
no structure here
```

# Appendix C. Variable-Length Integer Encoding

ANYTLS frames commonly use a variable-length encoding for non-negative integer values. This encoding ensures that smaller integer values need fewer bytes to encode.

The variable-length integer encoding reserves the two most significant bits of the first byte to encode the base-2 logarithm of the integer encoding length in bytes. The integer value is encoded on the remaining bits, in network byte order.

This means that integers are encoded on 1, 2, 4, or 8 bytes and can encode 6-, 14-, 30-, or 62-bit values, respectively.

| 2MSB | Length | Usable Bits | Range |
| --- | --- | --- | --- |
| 00 | 1 | 6 | 0-63 |
| 01 | 2 | 14 | 0-16383 |
| 10 | 4 | 30 | 0-1073741823 |
| 11 | 8 | 62 | 0-4611686018427387903 |
